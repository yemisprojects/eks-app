<h1 align="center">DevSecOps CI/CD with Jenkins and ArgoCD</h1>

This repository contains the source code and Jenkinsfile used to automate the Continous Integration phases of a CI/CD pipeline to EKS. Continous delivery is accomplished via ArgoCD. This repo is intended to be used with the two repositories listed below.
- [eks-infra](https://github.com/yemisprojects/eks-infra) repo: contains terraform code and github workflow to automate EKS deployment
- [kubernetes-manifests](https://github.com/yemisprojects/kubernetes-manifests) repo: contains helm charts for deployment by Argo CD

<h2>CI/CD Tools</h2>

The following tools have been used in this solution

- [Jenkins](https://www.jenkins.io) is an open source automation server which enables developers to reliably build, test, and deploy their software. With numerous plugins available it provides easy integration to many third party systems. If server management is a not a major concern, Jenkins is a great choice for CI/CD.
- [Maven](https://maven.apache.org) is a build automation tool used primarily for building and managing Java projects
- [Checkstyle](https://checkstyle.sourceforge.io) is a development tool to help programmers write Java code that adheres to a coding standard. It automates the process of checking Java code, this makes it ideal for projects that want to enforce a coding standard.
- [OWASP](https://owasp.org/www-project-dependency-check/) Dependency-Check is a Software Composition Analysis (SCA) tool that actively scans through a project's dependencies to detect and report on publicly disclosed vulnerabilities, thereby improving application security.
- [SonarQube](https://www.sonarsource.com/products/sonarqube/) (SAST) – Catches bugs and vulnerabilities in your app, with thousands of automated Static Code Analysis rules.
- [Trivy](https://aquasecurity.github.io/trivy/v0.47/) is an open-source comprehensive vulnerability scanner. It is quick and can scan filesystems, images, kubernetes cluster, IaC configuration, Git repository making it one of the most versatile security scanners available.
- [Argo CD](https://argo-cd.readthedocs.io/en/stable/) is a kubernetes controller which continuously monitors running applications and compares the current, live state against the desired target state specified in a Git repo. A deployed application whose live state deviates from the target state is considered OutOfSync. Argo CD reports & visualizes the differences, while providing facilities to automatically or manually sync the live state back to the desired target state. Any modifications made to the desired target state in the Git repo can be automatically applied and reflected in the specified target environments.

<h2 align="center">Pipeline Architecture</h2>

The following diagram shows the architecture of the solution
<img alt="DevSecOps CICD pipeline architecture" src="https://github.com/yemisprojects/eks-app/blob/main/images/Final_pipeline.png">

The main steps are as follows:
1. When a user commits code to a Git repository, a Github webhook triggers the Jenkins pipeline
2. Maven builds and packages the application. This package can be uploaded to an artificat store such as Nexus.
3. Various tests are carried out such as unit and Code coverage tests. It is also tested against coding standards using checkstyle. Results are analysed at a later step using SonarQube. 
4. Using Trivy, the filesystem is scanned for any vulnerabilities, leaked secrets or misconfigurations within files such as Docker
5. In parallel, OWASP scans for vulnerabilities within the project's dependencies. If either scans fail the pipeline execution fails
6. SonarQube uses the Checkstyle reports and test code coverage reports generated by Jacoco to run an analysis against the code. An analysis report is generated which includes details on Bugs, vulnerabilities, Code smells, test code coverage. Based on thresholds defined via a feature called Quality gate the pipeline will either pass or fail
7. If it passes, a docker image is built using Docker and the Maven build artifiact after which it is scanned for vulnerabilities using Trivy. If the scan passes, the image is uploaded to docker hub. 
8. Unused docker images are removed. Notifications are sent to a slack channel to alert a DevOps team on the status of the pipeline and reports are sent to a preconfigured email. The workspace is cleanup.
9. The pipeline triggers another job which updates the image tags in another git repository containing helm charts.
10. Once the change is commited, Argo CD detects the misalignment between the declared state of the application in the repository and it's running status and updates the running application in the EKS cluster if auto sync is enabled.  

## Application Stack
The application is exposed using the AWS Application Load Balancer and the stack consists of a Java application, MySQL, Rabbitmq and Memcache 

#### Application requirements
- JDK 1.8 or later
- Maven 3 or later
- MySQL 5.6 or later
<!--- 
## Technologies 
- Spring MVC
- Spring Security
- Spring Data JPA
- Maven
- JSP
- MySQL
--->
#### Docker Images
- Memchache and Rabbitmq official docker images will be used by the application in EKS
- The DB/MySQL image has been prebuilt with some dummy data and the official MySQL docker image. 
    - The script is located in this repo at `src/main/resources/db_backup.sql` 
    - The image is available on dockerhub with this tag, `yemisiomonijo/vprofiledb:1`
    - These are the commands used to create and push the `yemisiomonijo/vprofiledb:1` image to dockerhub, if you need them.
    ```sh
    cd Docker-files-local-test/db
    docker build -t yemisiomonijo/vprofiledb:1 . 
    docker push yemisiomonijo/vprofiledb:1 .
    ```
- The application image will be built and deployed by the Jenkins pipeline with GitOps
<!--- 
mysql -u <user_name> -p accounts < accountsdb.sql
--->
## CICD setup prerequisites
1. DockerHub account
2. SonarCloud account
3. Github account
4. Email address
5. Slack Channel
5. Jenkins Instance (This should have been deployed using instructions from my [eks-infra repo](https://github.com/yemisprojects/eks-infra))
6. EKS Cluster (This should have been deployed using instructions from my [eks-infra repo](https://github.com/yemisprojects/eks-infra))

## CI/CD initial setup (required)

#### Step 1. Setup Slack
- Create a new Slack account followed by a workspace using the [steps here](https://slack.com/help/articles/206845317-Create-a-Slack-workspace). 
- Within the new workspace [create a slack channel](https://slack.com/help/articles/201402297-Create-a-channel) named `k8s-jenkins-cicd`.
- Apply the Jenkins App within the Slack workspace. 
    - Go to the Slack Jenkins app [here](https://slack.com/apps/A0F7VRFKN-jenkins-ci?tab=more_info) → Click Install → Add to Slack
    - Choose the channel `k8s-jenkins-cicd`. 
    - Add Jenkins CI integration
    - Proceed with the Setup Instructions and note down the auto-generated _Integration token credential ID_

#### Step 2. Setup Github repository
- Fork this repository
- Create Github webhook: To trigger the Jenkins pipeline automatically after each push, create a github webhook with these steps
    - Go to your GitHub repository. Under Settings → Add Webhooks. Use the information below where _x.x.x.x_ is Jenkins EC2 public IP. Refresh the browser and confirm the test ping is successful. The Jenkins security group has been setup to allow Github webhook access
    ```
            Payload URL: http://x.x.x.x:8080/github-webhook/   
            Content type: application/json
    ```
- Create a Github personal access token(classic) with admin privileges and note down the token for a later step when setting up Jenkins

#### Step 3. Setup SonarCloud
- Go to the SonarCloud [website](https://sonarcloud.io/) and signup for a free account
- Create an organization and note down the name for a latter step
- Create a project named `vprofile-app`. 
- Create a webook 
    - Go to the `vprofile-app` → `Administration` → `Configuration` → `Webhooks`
    - Click Create and provide the information below, where _x.x.x.x_ is Jenkins EC2 public IP.
    ```
    Name: Jenkins
    URL: http://x.x.x.x:8080/sonarqube-webhook          
    ``` 
- Create a new Quality Gate using the steps below or use the documentation [here](https://docs.sonarsource.com/sonarcloud/standards/managing-quality-gates/#:~:text=To%20create%20a%20new%20quality,in%20Your%20Organization%20>%20Quality%20Gates.) if needed.
    - Go to Organization → Quality Gates → Create → Name (jenkins)
    - Add a condition. Select `On Overall Code` → `Quality Gate failes when` → `Bugs` → is greater than `50` (For test purposes)
    - The app used for this project has 29 bugs so the Quality gate test will pass
    - Ensure to set the new Quality gate as default to make sure that this quality gate will apply to any new code analysis
    <!---IMPORTANT https://jenkinshero.com/sonarqube-quality-gates-in-jenkins-build-pipeline/ --->

#### Step 4. Setup Jenkins
- Login to Jenkins via SSM to get the initial password with the command below: 
   ```sh 
   cat /var/lib/jenkins/secrets/initialAdminPassword
   ```

- Login to the Jenkins Web UI at `http://x.x.x.x:8080/` (where _x.x.x.x_ is Jenkins EC2 public IP) Use the default username `admin` and the password obtained above. Accept the recommendation to `Install the recommended plugins`. 

- #### Install Jenkins Plugins
    - Goto Manage Jenkins → Plugins → Available Plugins → Select all the plugins below → Install. If a plugin is not listed, it is most likely installed
        - SonarQube Scanner 
        - Email Extension Plugin
        - Eclipse Temurin Installer
        - OWASP Dependency-Check
        - Docker
        - Docker Commons
        - Docker Pipeline
        - Docker API
        - Docker-build-step
        - Slack Notification
        - Github Integration
        - HTML Publisher plugin
        - Blue Ocean plugin  (optional)

- #### Install Jenkins Tools
    - Goto Manage Jenkins → Tools. Install each tool using the configuration below. Click Apply and Save
        - JDK Installations
            - Name: jdk17
            - Tick Install automatically → Click Add Installer → Install from adoptium.net 
            - Version: JDK-17.0.8.1+1
        - SonarQube Scanner Installations
            - Name: sonar_scanner
            - Tick: Install automatically
            - Version: SonarQube Scanner 5.0.1.3006
        - Dependency-Check Installations
            - Name: dependency_check
            - Tick: Install automatically → Click Install from github.com
            - Version: dependency-check 6.5.1	

- #### Add credentials to Jenkins
    - Goto Jenkins Dashboard → Manage Jenkins → Credentials → Select global → Add credentials
    - Add Sonarqube token
        - Obtain the token by logging into SonarCloud. Goto My Account  → Security → Enter Token Name → Create a token → Click on Generate Token.
        - Add the sonar token in Jenkins using the configuration below and click Create. _Replace **** with sonarqube token_
        ```
             Kind: Secret text
             Secret: ****			        
             ID: sonar_token
             Description: sonar_token
        ```
    - Add Jenkins Slack integration token using the configuration below. _Replace **** with slack token_
    ```
            Kind: Secret text
            Secret: ****	          
            ID: slack_token
            Description: slack_token
    ```
    - Add Dockerhub login credential using the configuration below. _Replace **** with docker password and userx_ 
    ```
            Kind: Username with password
            Username: userx			
            Password: **** 		          		
            ID: docker_cred
            Description: docker_cred
    ```
    - Add Github personal token. _Replace userx with your GitHub username and **** with your [Github token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) with admin access_
    ```
            Kind: Username with password
            Username: userx			
            Password: **** 		          	
            ID: github_token
            Description: github_token
    ```  
    - Add email credentials. If you have a Gmail account, generate an App password using the [steps here](https://support.google.com/mail/answer/185833?hl=en). Add the email credential on Jenkins using the information below. _Replace **** with your app password_
    ```
        Kind: Username with password
	    Username: userx@gmail.com	
        Password: **** 		          		
	    ID: email_cred
        Description: email_cred
    ```
- #### Update Jenkins system configuration
  - Login to Jenkins, go to Dashboard → Manage Jenkins → System.Use the information below to add various server configurations

    - Under SonarQube servers and SonarQube installations, use the information below
	    ```
        Name: sonarcloud_server
  	    Server URL:  https://sonarcloud.io    
        Server authentication token: sonar_token
        ```

    -  Setup Email Notification under Extended Email Notification. Click Apply & Save
    ```
        SMTP server: smtp.gmail.com
        SMTP Port: 465
        Click Advanced
        Credentials: email_cred 
        Tick: Use SSL
        Default Content Type: HTML(text/html)
        Default triggers: 
            Tick: Always
                    Failure - Any
    ```

    - Under Slack, use the information below. Select test connection after setup. _Replace xxxx with the name of your slack workspace_
    ```
	Workspace:  xxxx  			
    credential: slack_token 
    Default channel: #k8s-jenkins-cicd   
    ```

- #### Create two Jenkins pipelines
    ##### Pipeline No. 1
    - On Jenkins Dashboard, click New Item → Select Pipeline → Enter Item name, e.g `k8s-pipeline` and click OK
    - Under Build triggers, select GitHub hook trigger for GITScm polling
    - Under Pipeline. Select these options. Replace _zzzzzzzz_ below with your github name, Apply and Click Save
    ```
            Definition: Pipeline script from SCM
            SCM: Git
            Repository URL: https://github.com/zzzzzzzz/eks-app
            Branch Specifier: */main
            Script Path: Jenkinsfile
    ```
    ##### Pipeline No. 2
    - On Jenkins Dashboard, click New Item → Select Pipeline → Enter this Item name, e.g `update-k8-manifest` and click OK
    - Under Pipeline. Select these options. Replace _zzzzzzzz_ with your github name, Apply and Click Save
    ```
            Tick: This project is parameterized
                Add Parameter -> Select String Parameter:
                    Name: DOCKER_TAG
            Definition: Pipeline script from SCM
            SCM: Git
            Repository URL: https://github.com/zzzzzzzz/kubernetes-manifests
            Branch Specifier: */main
            Script Path: Jenkinsfile
    ```

#### Step 5. Update Jenkinsfile 

After forking this eks-app repo, make the following changes to the Jenkinsfile

- Replace `yemisiomonijo` in the Jenkinsfile with your dockerhub username
```
.......
    environment {
        SONAR_SCANNER_HOME = tool 'sonar_scanner'
        DOCKER_REGISTRY = "yemisiomonijo/vprofileapp"
        DOCKER_REG_CRED = 'docker_reg_cred'
    }
```
- Replace `dummyuser@yahoo.com` with the email address you wish to receive pipeline notifications,  scan results and build logs.
```
.......
            emailext attachLog: true,
                subject: "'${currentBuild.result}'",
                body: "Project: ${env.JOB_NAME}<br/>" +
                        "Build Number: ${env.BUILD_NUMBER}<br/>" +
                        "URL: ${env.BUILD_URL}<br/>",
                to: 'dummyuser@yahoo.com',
                attachmentsPattern: 'filesystem_scanresults.txt,image_scan.txt'
```

#### Step 6. Update helm chart repository

- Fork the [kubernetes-manifest](https://github.com/yemisprojects/kubernetes-manifests) repository containing the application's helm charts
- Replace `yemisiomonijo` in the Jenkinsfile with your dockerhub username
```
........
    environment {
        DOCKER_REGISTRY = "yemisiomonijo/vprofileapp"
    }
```
- Replace `vprofile.devopsprotech.com` in the `webapp/templates/vproapp-ingress.yaml` file with a CNAME record to be used at a later step within your domain.
```
......
  rules:
    - host: vprofile.devopsprotech.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
```
- Push all changes to the repository

#### Step 7. Trigger Jenkins Pipeline
- Comit and push your changes to the main branch
- The Github webhook should trigger the `k8s-pipeline`. This is a pipeline view using blue ocean
<img alt="Pipeline stages" src="https://github.com/yemisprojects/eks-app/blob/main/images/Pipeline%201.png">

- The OWASP dependency scan results can be seen from the UI once the pipeline completes execution
<img alt="Dependency check results" src="https://github.com/yemisprojects/eks-app/blob/main/images/Dependency%20check%20results.png">

- The SonarQube Quality gate results is also shown on the Pipeline UI
<img alt="Quality Gate" src="https://github.com/yemisprojects/eks-app/blob/main/images/Sonarcloud%20quality%20gate.png">

- The `update-k8-manifest` pipeline is triggered after the `k8s-pipeline` completes. It updates the image application [tag](https://github.com/yemisprojects/kubernetes-manifests/blob/ec4bc16da4709f5aa6e5581e05b5e3333045a946/webapp/templates/vprofile-app-deployment.yml#L21) in the `kubernetes-manifests` repository
<img alt="Helm repo Update" src="https://github.com/yemisprojects/eks-app/blob/main/images/Pipeline%202.png">

- A slack notification should be recieved on the slack channel
<img alt="Slack notification" src="https://github.com/yemisprojects/eks-app/blob/main/images/slack%20notification.png">

- You should receive an email with attachment of the build log and trivy scan results. See the screenshot below.
<img alt="Email notice" src="https://github.com/yemisprojects/eks-app/blob/main/images/Email%20attachments.png">

- The Trivy scan results are also available as an HTML page from the Jenkins web UI. Click the Trivy scan tab as shown below
<img alt="Trivy scan 1" src="https://github.com/yemisprojects/eks-app/blob/main/images/plugins_accessible_from_Jenkins_build_UI.png">

- You should see it's scan results rendered as an HTML page
<img alt="Trivy scan 1" src="https://github.com/yemisprojects/eks-app/blob/main/images/trivy_scan_results.png">

#### Step 8. Login to ArgoCD UI and connect the app

- Login to Argo CD UI using the steps [here](https://github.com/yemisprojects/eks-infra#how-to-access-argo-cd-ui) in my eks-infra repo
- Connect your Github Helm chart repo to Argo CD controller. Go to `Settings` -> `Repositories` -> Click `Connect Repo`
    - Replace _xxxxx_ with your github username. Click Connect and verify the connection status shows _Successfull_ to represent connected
    ```
        Choose your authentication method: https
        Type: git
        Project: default
        Repository URL: https://github.com/xxxxx/kubernetes-manifests/tree/main
        username: Provide your github username
        Password: Provide a github token
    ```
    - A screenshot of the configuration is shown below. 
<img alt="Connect repo" src="https://github.com/yemisprojects/kubernetes-manifests/blob/main/images/Screenshot%202023-11-16%20at%202.40.24%E2%80%AFPM.png">

- Create a new app.
    - Goto `Applications` -> `NEW APP` and provide the information below and Click Create
        ```
        Application Name: vprofile
        Project Name: default
        Sync Policy: Automatic
        Repository URL: Seclect HELM and your repository URL should pop up automatically
        Path: webapp
        CLuster URL: https://kubernetes.default.svc
        Namespace: vprofile
        ```
    - Here is a screenshot for the configuration above
    <img alt="Create new app" src="https://github.com/yemisprojects/kubernetes-manifests/blob/main/images/Screenshot%202023-11-16%20at%202.03.37%E2%80%AFPM.png">

- Observe the deployment of application
    <img alt="argocd UI" src="https://github.com/yemisprojects/kubernetes-manifests/blob/main/images/Screenshot%202023-11-16%20at%202.38.30%E2%80%AFPM.png">

- A load balancer will be created to expose the web application using the ingress rule you created. Reference the screenshot below. Note that this can take some time (about 5mins)
        <img alt="Load balancer ingress" src="https://github.com/yemisprojects/eks-app/blob/develop/images/Loadbalancers-app-grafana.png">

## How to Access the application

- Once the application is deployed and ingress is provisioned. Obtain the DNS name of the loadbalancer (see screenshot above), add it as a CNAME record within your domain. The load balancer name is called `vprofileapp-ingress`
    - This is a snippet of the same change when using Route53
    <img alt="Route53 cname change" src="https://github.com/yemisprojects/eks-app/blob/main/images/R53_record.png">

    - To view the kubernetes resources for the application within its namespace named vprofile run the command below
    ```
    kubectl get all -n vprofile
    ```    
- Goto your web browser and provide your web address for your domain. In this example it is `vprofile.devopsprotech.com`. The default login credential is shown below.
```
username: admin_vp
password: admin_vp
```
- The app login page is shown below 
<img alt="Login page" src="https://github.com/yemisprojects/eks-app/blob/main/images/app_login_page.png">

- After logging in, you should see this page. You can play around the UI.
<img alt="Logged in user" src="https://github.com/yemisprojects/eks-app/blob/main/images/app_view_after_login.png">

## Grafana Dashboard access

- Follow the steps [here](https://github.com/yemisprojects/eks-infra#how-to-access-grafanna) in my eks-infra repo to access Grafana and import the Kubernetes dashboard.
- To view metrics and stats from Grafana for the vprofile application after importing. Goto `Dashboard` -> `Kubernetes/Compute Resources/Namespace (Workloads)`.
- This is the compute stats view for the vprofile application
<img alt="Grafana UI" src="https://github.com/yemisprojects/eks-app/blob/main/images/Grafana%20Dashboard_1.png">

- Additional image below shows memory stats for the app and backend pods

<img alt="Grafana UI 2" src="https://github.com/yemisprojects/eks-app/blob/main/images/Grafana_dashboard_2.png">

## View Horizontal Pod Autoscaler for app
- To see the HPA data for the app. Run these command. The output is shown as well
```sh
kubectl get hpa vproapp -n vprofile                                                                                                                                         ─╯
NAME      REFERENCE            TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
vproapp   Deployment/vproapp   0%/50%    1         10        1          4h1m
```

## Troubleshooting

- If there are any issues with pods, authenticate using the `eksadmin1` user mentioned in the eks-infra repo.
Run the command below and review the logs. Replace `eksadmin1` with the AWS CLI profile created for the `eksadmin1`user
```
aws eks update-kubeconfig --region us-east-1 --name eks-poc --profile <eksadmin1>
kubectl logs -f <pod name>
```
- To check the AWS load balancer controller logs
```sh
kubectl logs -f -n kube-system  -l app.kubernetes.io/name=aws-load-balancer-controller
```

## Other improvements or considerations

- OWASP Zap (DAST) can be implemented to improved the security posture of the application by finding security vulnerabilities in your running web applications.
- Trivy kubernetes scan operator can also be used to scan resources at run time from within the cluster
- ECR can be used for continous image scanning
- Access Management using RBAC and IAM should be adopted
- A logging solution should be used. Possibly adopt fluentd and stream logs to cloudwatch which can be fed/aggregated into other solutions


